#version 300 es

// this shader is used to initialize, or re-initialize, the Kuramoto oscillator textures
// specifically, we set the B and A channels of the textures
// (the R and G channels contain the current phase, and we just pass them through unchanged)

precision mediump float;

uniform sampler2D uOscillatorTexRead;
uniform sampler2D uMainTex;
uniform sampler2D uDepthTex;
uniform sampler2D uEdgeTex;

uniform float frequencyRange[2]; // the values that the user has currently chosen! not the lowest and highest frequency that _can_ be set by the GUI sliders. opposite of shader.frag
uniform int frequenciesVaryBy; // 0=don't vary, 1=depth, 2=edge, 3=brightness, 4=pattern, 5=random
uniform float frequencyCorrelationPatternSize; // used only when frequenciesVaryBy=4=pattern
uniform int kernelSizeShrunkBy; // 0=don't shrink, 1=depth, 2=edge
uniform float kernelMaxShrinkDivisor; // between 1.0 and positive infinity
uniform bool logPolarTransform;

in vec2 vTexCoord; // in webgl2, 'varying' becomes 'out' in vertex shader and 'in' in fragment shader
out vec4 fragColor;  // in webgl2, the builtin gl_FragColor no longer exists, so define an output variable for the fragment color

#define PI 3.14159265
#define TAU (2.0*PI)

// homemade file include feature, the javascript code will paste the file in here
#include-log-polar-transform.frag

// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner
// #TODO: choose and use a better noise function, maybe one by Stefan Gustavson https://github.com/ashima/webgl-noise or https://github.com/FarazzShaikh/glNoise
float rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

vec4 maybeInverseLogPolarTransform(sampler2D tex, vec2 uv)
{
	if (logPolarTransform)
	{
		ivec2 itexWidthHeight = textureSize(uOscillatorTexRead, 0);
		vec2 texWidthHeight = vec2(itexWidthHeight);
		return texture(tex, doLogPolarInverseTransform(texWidthHeight, uv));
		// return texture(tex, doLogPolarInverseTransform(texWidthHeight, doLogPolarTransform(texWidthHeight, uv))); // just to check my math
	}
	else
		return texture(tex, uv);
}

// why do we do this step in between? because we want to tweak the pixel values!
// the raw edge map on disk is a distance field generated by https://github.com/QualiaResearchInstitute/distance-field-maker
// where the grayscale color 0-255 is the distance to the nearest edge
// but the visual effects look much better if the falloff isn't linear
// tweak it so there's a sharp peak at the edge, and at first a steep falloff, then gradually a gentler and gentler slope
// yes we could precalculate this and bake it into the image file on disk,
// but it's nicer to be able to experiment and tweak values without regenerating the source image
float tweakEdgeDistance(float dist)
{
	// edge map: black = very edgy, white = very far from an edge
	if (dist != 0.0)
	{
		dist *= 2.0; // 255/3 is now the radius of the falloff region in pixels - how far from an edge the region extends
		dist = (1.172 - 1.0 / (5.0 * dist + 0.8));
		//dist = min(1.0, max(0.0, dist));
		//dist = sqrt(sqrt(dist));
		// the sin function seems like the most convenient to tweak
		// the first constant is uniform scaling. adjusts how far away from the edge that we reach sin=1 aka complete falloff
		// the second constant is non-uniform scaling. adjusts the curvature AND how far away from the edge we get complete falloff
		// 1.0 would give a normal sine wave, but we want one that curves sharply in the beginning near the edge, and then curves more and more slowly
		// desmos.com  sin(0.11 * x^0.1)
		// dist = Math.sin(Math.min(Math.PI / 2, 1.57079 * Math.pow(dist, 0.5)));
		dist = clamp(dist, 0.0, 1.0);
	}
	return dist;
}

float generateKernelSizeMultiplier()
{
	// scale the coupling kernel based on image depth map or edge map
	// how to scale? two ideas: linear or reciprocal
	// either way, we have to make sure to handle fully black and fully white pixels sensibly
	// depth map: white = near the camera, black = far away
	// edge map: black = very edgy, white = very nonedgy
	// if myDepthPixel.r is black, don't let the loopRadius go down to 0
	// and if myDepthPixel.r is white, don't let the loopRadius grow to infinity or huge sizes
	if (kernelSizeShrunkBy == 1) // smaller kernel in areas with faraway depth
	{
		float distanceFromCamera = maybeInverseLogPolarTransform(uDepthTex, vTexCoord).r; // honestly not sure if this is actual linear distance, or already scaled nonlinearly in the depth map images
		float kernelSizeMultiplier = 1.0 / (kernelMaxShrinkDivisor - (kernelMaxShrinkDivisor - 1.0) * distanceFromCamera);
		return kernelSizeMultiplier;
	}
	else if (kernelSizeShrunkBy == 2) // or smaller kernel at image edges
	{
		float distanceToEdge = tweakEdgeDistance(maybeInverseLogPolarTransform(uEdgeTex, vTexCoord).r);
		// for example, if kernelMaxShrinkDivisor is 5, we get
		// 1 / (5 - (5-1) * distanceToEdge) = 1 / (5 - 4 * distanceToEdge)
		// at one extreme, this would become
		// 1 / (5 - 4 * 0) = 1 / (5 - 0) = 1 / (5) = 0.2
		// and at the other extreme, this would become
		// 1 / (5 - 4 * 1) = 1 / (5 - 4) = 1 / 1 = 1
		// so kernelSizeMultiplier is always somewhere between 1/kernelMaxShrinkDivisor and 1
		float kernelSizeMultiplier = 1.0 / (kernelMaxShrinkDivisor - (kernelMaxShrinkDivisor - 1.0) * distanceToEdge);
		return kernelSizeMultiplier;
	}
	return 1.0;
}

// Custom function to generate spatially correlated frequencies
// this natural oscillator frequency controls the animation speed of the pattern, NOT the spatial scale
// (to control the spatial scale, change the coupling kernel size)
float generateFrequency()
{
	ivec2 itexWidthHeight = textureSize(uOscillatorTexRead, 0);
	vec2 texWidthHeight = vec2(itexWidthHeight);

	if (frequenciesVaryBy == 1) // lower frequency in areas with faraway depth
	{
		// depth map: white = near the camera, black = far away
		float nearness = maybeInverseLogPolarTransform(uDepthTex, vTexCoord).r;
		return frequencyRange[0] + nearness * (frequencyRange[1] - frequencyRange[0]);
	}
	else if (frequenciesVaryBy == 2) // or higher frequency at image edges
	{
		// edge map: black = very edgy, white = very nonedgy
		float edgeness = 1.0 - tweakEdgeDistance(maybeInverseLogPolarTransform(uEdgeTex, vTexCoord).r);
		return frequencyRange[0] + edgeness * (frequencyRange[1] - frequencyRange[0]);
	}
	else if (frequenciesVaryBy == 3) // lower frequency in dark areas, just so we get nice "segmentation"
	{
		vec4 texel = maybeInverseLogPolarTransform(uMainTex, vTexCoord);
		float brightness = (texel.r * 0.299 + texel.g * 0.587 + texel.b * 0.114);
		return frequencyRange[0] + brightness * (frequencyRange[1] - frequencyRange[0]);
	}
	else if (frequenciesVaryBy == 4)
	{
		// original formula was cos and sin(y * Math.PI / frequencyCorrelationPatternSize)
		// which didn't cooperate with our pacman wraparound aka torus topology
		// to get a continuous transition across the edges, we need to round to the nearest whole number of rotations
		// yes, this unfortunately means that the pattern (especially at large sizes) will have different size in x and y
		vec2 numRotations = max(vec2(1.0, 1.0), round(texWidthHeight / frequencyCorrelationPatternSize));
		vec2 adjustedFrequencyCorrelationPatternSize = 1.0 / numRotations;
		float noiseValue = cos(vTexCoord.x * 2.0 * PI / adjustedFrequencyCorrelationPatternSize.x) * sin(vTexCoord.y * 2.0 * PI / adjustedFrequencyCorrelationPatternSize.y);
		return frequencyRange[0] + (frequencyRange[1] - frequencyRange[0]) * (noiseValue + 1.0) / 2.0;
	}
	else if (frequenciesVaryBy == 5)
	{
		float noise01 = rand(vTexCoord);
		return frequencyRange[0] + noise01 * (frequencyRange[1] - frequencyRange[0]); // random frequency variation = doesn't look good
	}
	// else constant
	return frequencyRange[0];
}

void main() 
{
	vec4 oscillatorPrevVal = texture(uOscillatorTexRead, vTexCoord);
	float frequency = generateFrequency();
	float kernelSizeMultiplier = generateKernelSizeMultiplier();
	fragColor = vec4(oscillatorPrevVal.r, oscillatorPrevVal.g, frequency, kernelSizeMultiplier);
}
